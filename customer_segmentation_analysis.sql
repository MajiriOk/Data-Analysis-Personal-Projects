CREATE TABLE customer_data (
	invoice_number varchar(50),	
	customer_id varchar(50),	
	gender varchar(50),	
	age int,
	category varchar(50),
	quantity int,
	price numeric,
	payment_method varchar(50),
	invoice_date date,
	shopping_mall varchar(50)
)

--Dataset overview

SELECT *
FROM customer_data

--Check if dataset has no missing values

SELECT COUNT (*)
FROM customer_data

SELECT COUNT(DISTINCT(customer_id)) AS customers
FROM customer_data

--Spending by shopping mall
SELECT shopping_mall, SUM(quantity) orders, CAST(SUM(price) AS money) revenue
FROM customer_data
GROUP BY shopping_mall
ORDER BY 3 DESC;

--Spending by gender
SELECT gender, SUM(quantity) orders, CAST(SUM(price) AS money) revenue
from customer_data
GROUP BY gender
ORDER BY 3 DESC;

--Spending by category
SELECT category, SUM(quantity) orders, CAST(SUM(price) AS money) revenue
from customer_data
GROUP BY category
ORDER BY 3 DESC;

--top spending by year and gender
SELECT 
    EXTRACT(YEAR FROM invoice_date) AS year, 
    gender, 
    SUM(quantity) AS sales, 
    CAST(SUM(price) AS money) AS revenue
FROM 
    customer_data
GROUP BY 
    EXTRACT(YEAR FROM invoice_date), gender
ORDER BY 
    revenue DESC;

--top spending by year
SELECT 
    EXTRACT(YEAR FROM invoice_date) AS year,  
    SUM(quantity) AS sales, 
    CAST(SUM(price) AS money) AS revenue
FROM 
    customer_data
GROUP BY 
    EXTRACT(YEAR FROM invoice_date)
ORDER BY 
    revenue DESC;
	
	
-- RFM Analysis
SELECT
  customer_id, 
  gender, 
  age, 
  payment_method, 
  shopping_mall, 
 -- Calculate the number of days since the customer's last transaction by subtracting 
 -- the invoice date from the fixed date '2024-01-01'.
  ('2024-01-01'::date - invoice_date) AS last_date_order,
  SUM(quantity) AS total_orders,
  CAST(SUM(price) AS money) AS revenue
FROM 
  customer_data
-- Grouping by customer details and transaction-specific fields to summarize data for each customer
GROUP BY 
  customer_id, gender, age, payment_method, shopping_mall, invoice_date
-- Sorting the results by the days since the last transaction (most recent first)
ORDER BY 
  last_date_order;
  
--Further analysis with CTE
-- Common Table Expression (CTE) to calculate Recency, Frequency, and Monetary value per customer
WITH rfm AS (
 SELECT
    customer_id, 
  	gender, 
  	age, 
  	payment_method, 
  	shopping_mall, 
  	('2024-01-01'::date - invoice_date) AS last_date_order,
 -- Total number of items purchased by each customer
  	SUM(quantity) AS total_orders,
 -- Total revenue generated by each customer
  	CAST(SUM(price) AS money) AS revenue
 FROM customer_data
 GROUP BY customer_id, gender, age, payment_method, shopping_mall, invoice_date
 ORDER BY last_date_order
)
-- Final query: Perform RFM analysis by ranking customers based on Recency, Frequency, and Monetary value
SELECT *,
-- Rank customers into 3 groups (tiles) based on how recent their last purchase was
  NTILE(3) OVER (ORDER BY last_date_order) rfm_recency,
-- Rank customers into 3 groups based on how frequently they make purchases
  NTILE(3) OVER (ORDER BY total_orders) rfm_frequency,
-- Rank customers into 3 groups based on the total revenue they have generated
  NTILE(3) OVER (ORDER BY revenue) rfm_monetary
 FROM rfm -- Use the result of the CTE for further analysis
 
 
--Total RFM score
-- First CTE: Summarize customer orders, revenue, and recency information
WITH rfm AS (
 SELECT
    customer_id, 
  	gender, 
  	age, 
  	payment_method, 
  	shopping_mall, 
  	('2024-01-01'::date - invoice_date) AS last_date_order,
  	SUM(quantity) AS total_orders,
  	CAST(SUM(price) AS money) AS revenue
 FROM customer_data
 GROUP BY customer_id, gender, age, payment_method, shopping_mall, invoice_date
 ORDER BY last_date_order
),
-- Second CTE: Perform RFM segmentation based on Recency, Frequency, and Monetary value
rfm_calc AS (
 SELECT *,
  NTILE(3) OVER (ORDER BY last_date_order) rfm_recency,
  NTILE(3) OVER (ORDER BY total_orders) rfm_frequency,
  NTILE(3) OVER (ORDER BY revenue) rfm_monetary
 FROM rfm -- Use the results from the first CTE
 ORDER BY rfm_monetary DESC -- Sort by monetary value (highest spenders at the top)
)
-- Final query: Calculate the overall RFM score and create a combined RFM code
SELECT *,
-- Calculate the overall RFM score by adding recency, frequency, and monetary scores
	rfm_recency + rfm_frequency + rfm_monetary AS rfm_score,
-- Concatenate the RFM scores to create a unique 3-digit RFM code
	concat(rfm_recency, rfm_frequency, rfm_monetary) AS rfm
FROM rfm_calc -- Use the results from the second CTE


--Interprete RFM code
-- Select all columns, and create customer segments based on RFM scores
SELECT *, 
 CASE
 WHEN rfm IN ('311', '312', '311') THEN 'new customers'
 WHEN rfm IN ('111', '121', '131', '122', '133', '113', '112', '132') THEN 'lost customers'
 WHEN rfm IN ('212', '313', '123', '221', '211', '232') THEN 'regular customers'
 WHEN rfm IN ('223', '222', '213', '322', '231', '321', '331') THEN 'loyal customers'
 WHEN rfm IN ('333', '332', '323', '233') THEN 'top customers'
END rfm_segment -- Output the segment for each customer
FROM(
-- Subquery starts here
WITH rfm AS (
 -- First CTE: Summarize RFM data for each customer
 SELECT
    customer_id, 
  	gender, 
  	age, 
  	payment_method, 
  	shopping_mall, 
  	('2024-01-01'::date - invoice_date) AS last_date_order,
  	SUM(quantity) AS total_orders,
  	CAST(SUM(price) AS money) AS revenue
 FROM customer_data
 GROUP BY customer_id, gender, age, payment_method, shopping_mall, invoice_date
 ORDER BY last_date_order
),
rfm_calc AS (
 -- Second CTE: Calculate the RFM metrics using NTILE to divide customers into 3 groups
 SELECT *,
  NTILE(3) OVER (ORDER BY last_date_order) rfm_recency,
  NTILE(3) OVER (ORDER BY total_orders) rfm_frequency,
  NTILE(3) OVER (ORDER BY revenue) rfm_monetary
 FROM rfm
 ORDER BY rfm_monetary DESC
)
 -- Final step: Select data, calculate RFM score, and create the RFM code
SELECT *, rfm_recency + rfm_frequency + rfm_monetary AS rfm_score,
concat(rfm_recency, rfm_frequency, rfm_monetary) AS rfm
FROM rfm_calc -- Use the results from the second CTE
) rfm_tb; -- End of the subquery

